# coding: utf-8

"""
    xata

    xata.io API  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from XataClient.api_client import ApiClient


class RecordsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def bulk_insert_table_records(self, db_branch_name, table_name, **kwargs):  # noqa: E501
        """Bulk insert records  # noqa: E501

        Bulk insert records  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_insert_table_records(db_branch_name, table_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param TableNameBulkBody body:
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_insert_table_records_with_http_info(db_branch_name, table_name, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_insert_table_records_with_http_info(db_branch_name, table_name, **kwargs)  # noqa: E501
            return data

    def bulk_insert_table_records_with_http_info(self, db_branch_name, table_name, **kwargs):  # noqa: E501
        """Bulk insert records  # noqa: E501

        Bulk insert records  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_insert_table_records_with_http_info(db_branch_name, table_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param TableNameBulkBody body:
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['db_branch_name', 'table_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_insert_table_records" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'db_branch_name' is set
        if ('db_branch_name' not in params or
                params['db_branch_name'] is None):
            raise ValueError("Missing the required parameter `db_branch_name` when calling `bulk_insert_table_records`")  # noqa: E501
        # verify the required parameter 'table_name' is set
        if ('table_name' not in params or
                params['table_name'] is None):
            raise ValueError("Missing the required parameter `table_name` when calling `bulk_insert_table_records`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'db_branch_name' in params:
            path_params['db_branch_name'] = params['db_branch_name']  # noqa: E501
        if 'table_name' in params:
            path_params['table_name'] = params['table_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/db/{db_branch_name}/tables/{table_name}/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_record(self, db_branch_name, table_name, record_id, **kwargs):  # noqa: E501
        """Delete record from table  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_record(db_branch_name, table_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param RecordID record_id: The Record name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_record_with_http_info(db_branch_name, table_name, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_record_with_http_info(db_branch_name, table_name, record_id, **kwargs)  # noqa: E501
            return data

    def delete_record_with_http_info(self, db_branch_name, table_name, record_id, **kwargs):  # noqa: E501
        """Delete record from table  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_record_with_http_info(db_branch_name, table_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param RecordID record_id: The Record name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['db_branch_name', 'table_name', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'db_branch_name' is set
        if ('db_branch_name' not in params or
                params['db_branch_name'] is None):
            raise ValueError("Missing the required parameter `db_branch_name` when calling `delete_record`")  # noqa: E501
        # verify the required parameter 'table_name' is set
        if ('table_name' not in params or
                params['table_name'] is None):
            raise ValueError("Missing the required parameter `table_name` when calling `delete_record`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `delete_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'db_branch_name' in params:
            path_params['db_branch_name'] = params['db_branch_name']  # noqa: E501
        if 'table_name' in params:
            path_params['table_name'] = params['table_name']  # noqa: E501
        if 'record_id' in params:
            path_params['record_id'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/db/{db_branch_name}/tables/{table_name}/data/{record_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_record(self, db_branch_name, table_name, record_id, **kwargs):  # noqa: E501
        """Get record by ID  # noqa: E501

        Retrieve record by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_record(db_branch_name, table_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param RecordID record_id: The Record name (required)
        :return: Record
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_record_with_http_info(db_branch_name, table_name, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_record_with_http_info(db_branch_name, table_name, record_id, **kwargs)  # noqa: E501
            return data

    def get_record_with_http_info(self, db_branch_name, table_name, record_id, **kwargs):  # noqa: E501
        """Get record by ID  # noqa: E501

        Retrieve record by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_record_with_http_info(db_branch_name, table_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param RecordID record_id: The Record name (required)
        :return: Record
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['db_branch_name', 'table_name', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'db_branch_name' is set
        if ('db_branch_name' not in params or
                params['db_branch_name'] is None):
            raise ValueError("Missing the required parameter `db_branch_name` when calling `get_record`")  # noqa: E501
        # verify the required parameter 'table_name' is set
        if ('table_name' not in params or
                params['table_name'] is None):
            raise ValueError("Missing the required parameter `table_name` when calling `get_record`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `get_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'db_branch_name' in params:
            path_params['db_branch_name'] = params['db_branch_name']  # noqa: E501
        if 'table_name' in params:
            path_params['table_name'] = params['table_name']  # noqa: E501
        if 'record_id' in params:
            path_params['record_id'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/db/{db_branch_name}/tables/{table_name}/data/{record_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Record',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insert_record(self, db_branch_name, table_name, **kwargs):  # noqa: E501
        """Insert record  # noqa: E501

        Insert a new Record into the Table  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insert_record(db_branch_name, table_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param object body:
        :return: InlineResponse2012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insert_record_with_http_info(db_branch_name, table_name, **kwargs)  # noqa: E501
        else:
            (data) = self.insert_record_with_http_info(db_branch_name, table_name, **kwargs)  # noqa: E501
            return data

    def insert_record_with_http_info(self, db_branch_name, table_name, **kwargs):  # noqa: E501
        """Insert record  # noqa: E501

        Insert a new Record into the Table  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insert_record_with_http_info(db_branch_name, table_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param object body:
        :return: InlineResponse2012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['db_branch_name', 'table_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insert_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'db_branch_name' is set
        if ('db_branch_name' not in params or
                params['db_branch_name'] is None):
            raise ValueError("Missing the required parameter `db_branch_name` when calling `insert_record`")  # noqa: E501
        # verify the required parameter 'table_name' is set
        if ('table_name' not in params or
                params['table_name'] is None):
            raise ValueError("Missing the required parameter `table_name` when calling `insert_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'db_branch_name' in params:
            path_params['db_branch_name'] = params['db_branch_name']  # noqa: E501
        if 'table_name' in params:
            path_params['table_name'] = params['table_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/db/{db_branch_name}/tables/{table_name}/data', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def insert_record_with_id(self, db_branch_name, table_name, record_id, **kwargs):  # noqa: E501
        """Insert record with ID  # noqa: E501

        By default, IDs are auto-generated when data is insterted into Xata. Sending a request to this endpoint allows us to insert a record with a pre-existing ID, bypassing the default automatic ID generation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insert_record_with_id(db_branch_name, table_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param RecordID record_id: The Record name (required)
        :param object body:
        :param bool create_only:
        :param int if_version:
        :return: InlineResponse2012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.insert_record_with_id_with_http_info(db_branch_name, table_name, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.insert_record_with_id_with_http_info(db_branch_name, table_name, record_id, **kwargs)  # noqa: E501
            return data

    def insert_record_with_id_with_http_info(self, db_branch_name, table_name, record_id, **kwargs):  # noqa: E501
        """Insert record with ID  # noqa: E501

        By default, IDs are auto-generated when data is insterted into Xata. Sending a request to this endpoint allows us to insert a record with a pre-existing ID, bypassing the default automatic ID generation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.insert_record_with_id_with_http_info(db_branch_name, table_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param RecordID record_id: The Record name (required)
        :param object body:
        :param bool create_only:
        :param int if_version:
        :return: InlineResponse2012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['db_branch_name', 'table_name', 'record_id', 'body', 'create_only', 'if_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method insert_record_with_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'db_branch_name' is set
        if ('db_branch_name' not in params or
                params['db_branch_name'] is None):
            raise ValueError("Missing the required parameter `db_branch_name` when calling `insert_record_with_id`")  # noqa: E501
        # verify the required parameter 'table_name' is set
        if ('table_name' not in params or
                params['table_name'] is None):
            raise ValueError("Missing the required parameter `table_name` when calling `insert_record_with_id`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `insert_record_with_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'db_branch_name' in params:
            path_params['db_branch_name'] = params['db_branch_name']  # noqa: E501
        if 'table_name' in params:
            path_params['table_name'] = params['table_name']  # noqa: E501
        if 'record_id' in params:
            path_params['record_id'] = params['record_id']  # noqa: E501

        query_params = []
        if 'create_only' in params:
            query_params.append(('createOnly', params['create_only']))  # noqa: E501
        if 'if_version' in params:
            query_params.append(('ifVersion', params['if_version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/db/{db_branch_name}/tables/{table_name}/data/{record_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_table(self, db_branch_name, table_name, **kwargs):  # noqa: E501
        """Query table  # noqa: E501

        The Query Table API can be used to retrieve all records in a table. The API support filtering, sorting, selecting a subset of columns, and pagination.  The overall structure of the request looks like this:  ```json // POST /db/<dbname>:<branch>/tables/<table>/query {   \"columns\": [...],   \"filter\": {     \"$all\": [...]     \"$any\": [...]     ...   },   \"sort\": {     \"multiple\": [...]     ...   },   \"page\": {     ...   } } ```  ### Column selection  If the `columns` array is not specified, all columns are included. For link fields, only the ID column of the linked records is included in the response.  If the `columns` array is specified, only the selected columns are included. The `*` wildcard can be used to select all columns of the given array  For objects and link fields, if the column name of the object is specified, we include all of its sub-keys. If only some sub-keys are specified (via dotted notation, e.g. `\"settings.plan\"` ), then only those sub-keys from the object are included.  By the way of example, assuming two tables like this:  ```json {\"truncate\": true} {   \"formatVersion\": \"1.0\",   \"tables\": [     {       \"name\": \"teams\",       \"columns\": [         {           \"name\": \"name\",           \"type\": \"string\"         },         {           \"name\": \"owner\",           \"type\": \"link\",           \"link\": {             \"table\": \"users\"           }         }       ]     },     {       \"name\": \"users\",       \"columns\": [         {           \"name\": \"email\",           \"type\": \"email\"         },         {           \"name\": \"full_name\",           \"type\": \"string\"         },         {           \"name\": \"address\",           \"type\": \"object\",           \"columns\": [             {               \"name\": \"street\",               \"type\": \"string\"             },             {               \"name\": \"number\",               \"type\": \"int\"             },             {               \"name\": \"zipcode\",               \"type\": \"int\"             }           ]         },         {           \"name\": \"team\",           \"type\": \"link\",           \"link\": {             \"table\": \"teams\"           }         }       ]     }   ] } ```  A query like this:  ```json POST /db/<dbname>:<branch>/tables/<table>/query {   \"columns\": [     \"name\",     \"address.*\"   ] } ```  returns objects like:  ```json {   \"name\": \"Kilian\",   \"address\": {     \"street\": \"New street\",     \"number\": 41,     \"zipcode\": 10407   } } ```  while a query like this:  ```json POST /db/<dbname>:<branch>/tables/<table>/query {   \"columns\": [     \"name\",     \"address.street\"   ] } ```  returns objects like:  ```json {   \"name\": \"Kilian\",   \"address\": {     \"street\": \"New street\",   } } ```  If you want to return all columns from the main table and selected columns from the linked table, you can do it like this:  ```json {   \"columns\": [     \"*\",     \"team.name\"   ] } ```  The `\"*\"` in the above means all columns, including columns of objects. This returns data like:  ```json {   \"name\": \"Kilian\",   \"email\": \"kilian@gmail.com\",   \"address\": {     \"street\": \"New street\",     \"number\": 41,     \"zipcode\": 10407   },   \"team\": {     \"id\": \"XX\",     \"xata\": {       \"version\": 0,     },     \"name\": \"first team\"   } } ```  If you want all columns of the linked table, you can do:  ```json {   \"columns\": [     \"*\",     \"team.*\"   ] } ```  This returns, for example:  ```json {   \"name\": \"Kilian\",   \"email\": \"kilian@gmail.com\",   \"address\": {     \"street\": \"New street\",     \"number\": 41,     \"zipcode\": 10407   },   \"team\": {     \"id\": \"XX\",     \"xata\": {       \"version\": 0,     },     \"name\": \"first team\",     \"code\": \"A1\"   } } ```  ### Filtering  There are two types of operators:  - Operators that work on a single column: `$is`, `$contains`, `$pattern`,   `$includes`, `$gt`, etc. - Control operators that combine multiple conditions: `$any`, `$all`, `$not` ,   `$none`, etc.  All operators start with an `$` to differentiate them from column names (which are not allowed to start with an dollar sign).  #### Exact matching and control operators  Filter by one column:  ```json {   \"filter\": {     \"<column_name>\": \"value\"   } } ```  This is equivalent to using the `$is` operator:  ```json {   \"filter\": {     \"<column_name>\": {       \"$is\": \"value\"     }   } } ```  For example:  ```json {   \"filter\": {       \"name\": \"r2\",   } } ```  Or:  ```json {   \"filter\": {     \"name\": {       \"$is\": \"r2\"     }   } } ```  For objects, both dots and nested versions work:  ```json {   \"filter\": {       \"settings.plan\": \"free\",   } } ```  ```json {   \"filter\": {     \"settings\": {       \"plan\": \"free\"     },   }, } ```  If you want to OR together multiple values, you can use the `$any` operator with an array of values:  ```json {   \"filter\": {     \"settings.plan\": {\"$any\": [\"free\", \"paid\"]}   }, } ```  If you specify multiple columns in the same filter, they are logically AND'ed together:  ```json {   \"filter\": {       \"settings.dark\": true,       \"settings.plan\": \"free\",   }, } ```  The above matches if both conditions are met.  To be more explicit about it, you can use `$all` or `$any`:  ```json {   \"filter\": {       \"$any\": {         \"settings.dark\": true,         \"settings.plan\": \"free\"       }   }, } ```  The `$all` and `$any` operators can also receive an array of objects, which allows for repeating column names:  ```json {   \"filter\": {     \"$any\": [       {         \"name\": \"r1\",       },       {         \"name\": \"r2\",       },     ], } ```  You can check for a value being not-null with `$exists`:  ```json {   \"filter\": {     \"$exists\": \"settings\",   }, } ```  This can be combined with `$all` or `$any` :  ```json {   \"filter\": {     \"$all\": [       {         \"$exists\": \"settings\",       },       {         \"$exists\": \"name\",       },     ],   } } ```  Or you can use the inverse operator `$notExists`:  ```json {   \"filter\": {     \"$notExists\": \"settings\",   }, } ```  #### Partial match  `$contains` is the simplest operator for partial matching. We should generally discourage overusing `$contains` because it typically can't make use of indices.  ```json {   \"filter\": {     \"<column_name>\": {       \"$contains\": \"value\"     }   } } ```  Wildcards are supported via the `$pattern` operator:  ```json {   \"filter\": {     \"<column_name>\": {         \"$pattern\": \"v*alue*\"     }   } } ```  We could also have `$endsWith` and `$startsWith` operators:  ```json {   \"filter\": {     \"<column_name>\": {         \"$endsWith\": \".gz\"     },     \"<column_name>\": {         \"$startsWith\": \"tmp-\"     }   } } ```  #### Numeric ranges  ```json {   \"filter\": {       \"<column_name>\": {         \"$ge\": 0,         \"$lt\": 100       }   } } ```  The supported operators are `$gt`, `$lt`, `$ge`, `$le`.   #### Negations  A general `$not` operator can inverse any operation.  ```json {   \"filter\": {     \"$not\": {       \"<column_name1>\": \"value1\",       \"<column_name2>\": \"value1\"     }   } } ```  Note: in the above the two condition are AND together, so this does (NOT ( ... AND ...))  Or more complex:  ```json {   \"filter\": {     \"$not\": {       \"$any\": [{         \"<column_name1>\": \"value1\"       }, {         \"$all\": [{           \"<column_name2>\": \"value2\"         }, {           \"<column_name3>\": \"value3\"         }]       }]     }   } } ```  The `$not: { $any: {}}` can be shorted using the `$none` operator:  ```json {   \"filter\": {     \"$none\": {       \"<column_name1>\": \"value1\",       \"<column_name2>\": \"value1\"     }   } } ```  In addition, you can use operators like `$isNot` or `$notExists` to simplify expressions:  ```json {   \"filter\": {     \"<column_name>\": {       \"$isNot\": \"2019-10-12T07:20:50.52Z\"     }   } } ```  #### Working with arrays  To test that an array contains a value, use `$includes`.  ```json {   \"filter\": {     \"<array_name>\": {       \"$includes\": \"value\"     }   } } ```  The `$includes` operator accepts a custom predicate that will check if any array values matches the predicate. For example a complex predicate can include the `$all` , `$contains` and `$endsWith` operators:  ```json {   \"filter\": {     \"<array name>\": {       \"$includes\": {         \"$all\": [           {\"$contains\": \"label\"},           {\"$not\": {\"$endsWith\": \"-debug\"}}         ]       }     }   } } ```  The `$includes` all operator succeeds if any column in the array matches the predicate. The `$includesAll` operator succeeds if all array items match the predicate. The `$includesNone` operator succeeds if no array item matches the predicate. The `$includes` operator is a synonym for the `$includesAny` operator.  Here is an example of using the `$includesAll` operator:  ```json {   \"filter\": {     \"settings.labels\": {       \"$includesAll\": [         {\"$contains\": \"label\"},       ]     }   } } ```  The above matches if all label values contain the string \"labels\".  ### Sorting  Sorting by one element:  ```json POST /db/demo:main/tables/table/query {   \"sort\": {     \"index\": \"asc\"   } } ```  or descendently:  ```json POST /db/demo:main/tables/table/query {   \"sort\": {     \"index\": \"desc\"   } } ```  Sorting by multiple fields:  ```json POST /db/demo:main/tables/table/query {   \"sort\": [     {       \"index\": \"desc\"     },     {       \"createdAt\": \"desc\"     }   ] } ```   ### Pagination  We offer cursor pagination and offset pagination. The offset pagination is limited in the amount of data it can retrieve, so we recommend the cursor pagination if you have more than 1000 records.  Example of size + offset pagination:  ```json POST /db/demo:main/tables/table/query {   \"page\": {     \"size\": 100,     \"offset\": 200   } } ```  The `page.size` parameter represents the maximum number of records returned by this query. It has a default value of 20 and a maximum value of 200. The `page.offset` parameter represents the number of matching records to skip. It has a default value of 0 and a maximum value of 800.  Example of cursor pagination:  ```json POST /db/demo:main/tables/table/query {   \"page\": {     \"after\":\"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\"   } } ```  In the above example, the value of the `page.after` parameter is the cursor returned by the previous query. A sample response is shown below:  ```json {   \"meta\": {     \"page\": {       \"cursor\": \"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\",       \"more\": true     }   },   \"records\": [...] } ```  The `page` object might contain the follow keys, in addition to `size` and `offset` that were introduced before:  - `after`: Return the next page 'after' the current cursor - `before`: Return the previous page 'before' the current cursor. - `first`: Return the first page in the table from a cursor. - `last`: Return the last N records in the table from a cursor, where N is the `page.size` parameter.  The request will fail if an invalid cursor value is given to `page.before`, `page.after`, `page.first` , or `page.last`. No other cursor setting can be used if `page.first` or `page.last` is set in a query.  If both `page.before` and `page.after` parameters are present we treat the request as a range query. The range query will return all entries after `page.after`, but before `page.before`, up to `page.size` or the maximum page size. This query requires both cursors to use the same filters and sort settings, plus we require `page.after < page.before`. The range query returns a new cursor. If the range encompass multiple pages the next page in the range can be queried by update `page.after` to the returned cursor while keeping the `page.before` cursor from the first range query.  The `filter` , `columns`,  `sort` , and `page.size` configuration will be encoded with the cursor.  The pagination request will be invalid if `filter` or `sort` is set. The columns returned and page size can be changed anytime by passing the `columns` or `page.size` settings to the next query.  **Special cursors:**  - `page.after=end`: Result points past the last entry. The list of records   returned is empty, but `page.meta.cursor` will include a cursor that can be   used to \"tail\" the table from the end waiting for new data to be inserted. - `page.before=end`: This cursor returns the last page. - `page.first=<cursor>`: Go to first page. This is equivalent to querying the   first page without a cursor but `filter` and `sort` . Yet the `page.first`   cursor can be convenient at times as user code does not need to remember the   filter, sort, columns or page size configuration. All these information are   read from the cursor. - `page.last=<cursor>`: Go to the end of the table. This is equivalent to querying the   last page with `page.before=end`, `filter`, and `sort` . Yet the   `page.last` cursor can be more convenient at times as user code does not   need to remember the filter, sort, columns or page size configuration. All   these information are read from the cursor.  When using special cursors like `page.after=\"end\"` or `page.before=\"end\"`, we still allow `filter` and `sort` to be set.  Example of getting the last page:  ```json POST /db/demo:main/tables/table/query {   \"page\": {     \"size\": 10,     \"before\": \"end\"   } } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_table(db_branch_name, table_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param TableNameQueryBody body:
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.query_table_with_http_info(db_branch_name, table_name, **kwargs)  # noqa: E501
        else:
            (data) = self.query_table_with_http_info(db_branch_name, table_name, **kwargs)  # noqa: E501
            return data

    def query_table_with_http_info(self, db_branch_name, table_name, **kwargs):  # noqa: E501
        """Query table  # noqa: E501

        The Query Table API can be used to retrieve all records in a table. The API support filtering, sorting, selecting a subset of columns, and pagination.  The overall structure of the request looks like this:  ```json // POST /db/<dbname>:<branch>/tables/<table>/query {   \"columns\": [...],   \"filter\": {     \"$all\": [...]     \"$any\": [...]     ...   },   \"sort\": {     \"multiple\": [...]     ...   },   \"page\": {     ...   } } ```  ### Column selection  If the `columns` array is not specified, all columns are included. For link fields, only the ID column of the linked records is included in the response.  If the `columns` array is specified, only the selected columns are included. The `*` wildcard can be used to select all columns of the given array  For objects and link fields, if the column name of the object is specified, we include all of its sub-keys. If only some sub-keys are specified (via dotted notation, e.g. `\"settings.plan\"` ), then only those sub-keys from the object are included.  By the way of example, assuming two tables like this:  ```json {\"truncate\": true} {   \"formatVersion\": \"1.0\",   \"tables\": [     {       \"name\": \"teams\",       \"columns\": [         {           \"name\": \"name\",           \"type\": \"string\"         },         {           \"name\": \"owner\",           \"type\": \"link\",           \"link\": {             \"table\": \"users\"           }         }       ]     },     {       \"name\": \"users\",       \"columns\": [         {           \"name\": \"email\",           \"type\": \"email\"         },         {           \"name\": \"full_name\",           \"type\": \"string\"         },         {           \"name\": \"address\",           \"type\": \"object\",           \"columns\": [             {               \"name\": \"street\",               \"type\": \"string\"             },             {               \"name\": \"number\",               \"type\": \"int\"             },             {               \"name\": \"zipcode\",               \"type\": \"int\"             }           ]         },         {           \"name\": \"team\",           \"type\": \"link\",           \"link\": {             \"table\": \"teams\"           }         }       ]     }   ] } ```  A query like this:  ```json POST /db/<dbname>:<branch>/tables/<table>/query {   \"columns\": [     \"name\",     \"address.*\"   ] } ```  returns objects like:  ```json {   \"name\": \"Kilian\",   \"address\": {     \"street\": \"New street\",     \"number\": 41,     \"zipcode\": 10407   } } ```  while a query like this:  ```json POST /db/<dbname>:<branch>/tables/<table>/query {   \"columns\": [     \"name\",     \"address.street\"   ] } ```  returns objects like:  ```json {   \"name\": \"Kilian\",   \"address\": {     \"street\": \"New street\",   } } ```  If you want to return all columns from the main table and selected columns from the linked table, you can do it like this:  ```json {   \"columns\": [     \"*\",     \"team.name\"   ] } ```  The `\"*\"` in the above means all columns, including columns of objects. This returns data like:  ```json {   \"name\": \"Kilian\",   \"email\": \"kilian@gmail.com\",   \"address\": {     \"street\": \"New street\",     \"number\": 41,     \"zipcode\": 10407   },   \"team\": {     \"id\": \"XX\",     \"xata\": {       \"version\": 0,     },     \"name\": \"first team\"   } } ```  If you want all columns of the linked table, you can do:  ```json {   \"columns\": [     \"*\",     \"team.*\"   ] } ```  This returns, for example:  ```json {   \"name\": \"Kilian\",   \"email\": \"kilian@gmail.com\",   \"address\": {     \"street\": \"New street\",     \"number\": 41,     \"zipcode\": 10407   },   \"team\": {     \"id\": \"XX\",     \"xata\": {       \"version\": 0,     },     \"name\": \"first team\",     \"code\": \"A1\"   } } ```  ### Filtering  There are two types of operators:  - Operators that work on a single column: `$is`, `$contains`, `$pattern`,   `$includes`, `$gt`, etc. - Control operators that combine multiple conditions: `$any`, `$all`, `$not` ,   `$none`, etc.  All operators start with an `$` to differentiate them from column names (which are not allowed to start with an dollar sign).  #### Exact matching and control operators  Filter by one column:  ```json {   \"filter\": {     \"<column_name>\": \"value\"   } } ```  This is equivalent to using the `$is` operator:  ```json {   \"filter\": {     \"<column_name>\": {       \"$is\": \"value\"     }   } } ```  For example:  ```json {   \"filter\": {       \"name\": \"r2\",   } } ```  Or:  ```json {   \"filter\": {     \"name\": {       \"$is\": \"r2\"     }   } } ```  For objects, both dots and nested versions work:  ```json {   \"filter\": {       \"settings.plan\": \"free\",   } } ```  ```json {   \"filter\": {     \"settings\": {       \"plan\": \"free\"     },   }, } ```  If you want to OR together multiple values, you can use the `$any` operator with an array of values:  ```json {   \"filter\": {     \"settings.plan\": {\"$any\": [\"free\", \"paid\"]}   }, } ```  If you specify multiple columns in the same filter, they are logically AND'ed together:  ```json {   \"filter\": {       \"settings.dark\": true,       \"settings.plan\": \"free\",   }, } ```  The above matches if both conditions are met.  To be more explicit about it, you can use `$all` or `$any`:  ```json {   \"filter\": {       \"$any\": {         \"settings.dark\": true,         \"settings.plan\": \"free\"       }   }, } ```  The `$all` and `$any` operators can also receive an array of objects, which allows for repeating column names:  ```json {   \"filter\": {     \"$any\": [       {         \"name\": \"r1\",       },       {         \"name\": \"r2\",       },     ], } ```  You can check for a value being not-null with `$exists`:  ```json {   \"filter\": {     \"$exists\": \"settings\",   }, } ```  This can be combined with `$all` or `$any` :  ```json {   \"filter\": {     \"$all\": [       {         \"$exists\": \"settings\",       },       {         \"$exists\": \"name\",       },     ],   } } ```  Or you can use the inverse operator `$notExists`:  ```json {   \"filter\": {     \"$notExists\": \"settings\",   }, } ```  #### Partial match  `$contains` is the simplest operator for partial matching. We should generally discourage overusing `$contains` because it typically can't make use of indices.  ```json {   \"filter\": {     \"<column_name>\": {       \"$contains\": \"value\"     }   } } ```  Wildcards are supported via the `$pattern` operator:  ```json {   \"filter\": {     \"<column_name>\": {         \"$pattern\": \"v*alue*\"     }   } } ```  We could also have `$endsWith` and `$startsWith` operators:  ```json {   \"filter\": {     \"<column_name>\": {         \"$endsWith\": \".gz\"     },     \"<column_name>\": {         \"$startsWith\": \"tmp-\"     }   } } ```  #### Numeric ranges  ```json {   \"filter\": {       \"<column_name>\": {         \"$ge\": 0,         \"$lt\": 100       }   } } ```  The supported operators are `$gt`, `$lt`, `$ge`, `$le`.   #### Negations  A general `$not` operator can inverse any operation.  ```json {   \"filter\": {     \"$not\": {       \"<column_name1>\": \"value1\",       \"<column_name2>\": \"value1\"     }   } } ```  Note: in the above the two condition are AND together, so this does (NOT ( ... AND ...))  Or more complex:  ```json {   \"filter\": {     \"$not\": {       \"$any\": [{         \"<column_name1>\": \"value1\"       }, {         \"$all\": [{           \"<column_name2>\": \"value2\"         }, {           \"<column_name3>\": \"value3\"         }]       }]     }   } } ```  The `$not: { $any: {}}` can be shorted using the `$none` operator:  ```json {   \"filter\": {     \"$none\": {       \"<column_name1>\": \"value1\",       \"<column_name2>\": \"value1\"     }   } } ```  In addition, you can use operators like `$isNot` or `$notExists` to simplify expressions:  ```json {   \"filter\": {     \"<column_name>\": {       \"$isNot\": \"2019-10-12T07:20:50.52Z\"     }   } } ```  #### Working with arrays  To test that an array contains a value, use `$includes`.  ```json {   \"filter\": {     \"<array_name>\": {       \"$includes\": \"value\"     }   } } ```  The `$includes` operator accepts a custom predicate that will check if any array values matches the predicate. For example a complex predicate can include the `$all` , `$contains` and `$endsWith` operators:  ```json {   \"filter\": {     \"<array name>\": {       \"$includes\": {         \"$all\": [           {\"$contains\": \"label\"},           {\"$not\": {\"$endsWith\": \"-debug\"}}         ]       }     }   } } ```  The `$includes` all operator succeeds if any column in the array matches the predicate. The `$includesAll` operator succeeds if all array items match the predicate. The `$includesNone` operator succeeds if no array item matches the predicate. The `$includes` operator is a synonym for the `$includesAny` operator.  Here is an example of using the `$includesAll` operator:  ```json {   \"filter\": {     \"settings.labels\": {       \"$includesAll\": [         {\"$contains\": \"label\"},       ]     }   } } ```  The above matches if all label values contain the string \"labels\".  ### Sorting  Sorting by one element:  ```json POST /db/demo:main/tables/table/query {   \"sort\": {     \"index\": \"asc\"   } } ```  or descendently:  ```json POST /db/demo:main/tables/table/query {   \"sort\": {     \"index\": \"desc\"   } } ```  Sorting by multiple fields:  ```json POST /db/demo:main/tables/table/query {   \"sort\": [     {       \"index\": \"desc\"     },     {       \"createdAt\": \"desc\"     }   ] } ```   ### Pagination  We offer cursor pagination and offset pagination. The offset pagination is limited in the amount of data it can retrieve, so we recommend the cursor pagination if you have more than 1000 records.  Example of size + offset pagination:  ```json POST /db/demo:main/tables/table/query {   \"page\": {     \"size\": 100,     \"offset\": 200   } } ```  The `page.size` parameter represents the maximum number of records returned by this query. It has a default value of 20 and a maximum value of 200. The `page.offset` parameter represents the number of matching records to skip. It has a default value of 0 and a maximum value of 800.  Example of cursor pagination:  ```json POST /db/demo:main/tables/table/query {   \"page\": {     \"after\":\"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\"   } } ```  In the above example, the value of the `page.after` parameter is the cursor returned by the previous query. A sample response is shown below:  ```json {   \"meta\": {     \"page\": {       \"cursor\": \"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\",       \"more\": true     }   },   \"records\": [...] } ```  The `page` object might contain the follow keys, in addition to `size` and `offset` that were introduced before:  - `after`: Return the next page 'after' the current cursor - `before`: Return the previous page 'before' the current cursor. - `first`: Return the first page in the table from a cursor. - `last`: Return the last N records in the table from a cursor, where N is the `page.size` parameter.  The request will fail if an invalid cursor value is given to `page.before`, `page.after`, `page.first` , or `page.last`. No other cursor setting can be used if `page.first` or `page.last` is set in a query.  If both `page.before` and `page.after` parameters are present we treat the request as a range query. The range query will return all entries after `page.after`, but before `page.before`, up to `page.size` or the maximum page size. This query requires both cursors to use the same filters and sort settings, plus we require `page.after < page.before`. The range query returns a new cursor. If the range encompass multiple pages the next page in the range can be queried by update `page.after` to the returned cursor while keeping the `page.before` cursor from the first range query.  The `filter` , `columns`,  `sort` , and `page.size` configuration will be encoded with the cursor.  The pagination request will be invalid if `filter` or `sort` is set. The columns returned and page size can be changed anytime by passing the `columns` or `page.size` settings to the next query.  **Special cursors:**  - `page.after=end`: Result points past the last entry. The list of records   returned is empty, but `page.meta.cursor` will include a cursor that can be   used to \"tail\" the table from the end waiting for new data to be inserted. - `page.before=end`: This cursor returns the last page. - `page.first=<cursor>`: Go to first page. This is equivalent to querying the   first page without a cursor but `filter` and `sort` . Yet the `page.first`   cursor can be convenient at times as user code does not need to remember the   filter, sort, columns or page size configuration. All these information are   read from the cursor. - `page.last=<cursor>`: Go to the end of the table. This is equivalent to querying the   last page with `page.before=end`, `filter`, and `sort` . Yet the   `page.last` cursor can be more convenient at times as user code does not   need to remember the filter, sort, columns or page size configuration. All   these information are read from the cursor.  When using special cursors like `page.after=\"end\"` or `page.before=\"end\"`, we still allow `filter` and `sort` to be set.  Example of getting the last page:  ```json POST /db/demo:main/tables/table/query {   \"page\": {     \"size\": 10,     \"before\": \"end\"   } } ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_table_with_http_info(db_branch_name, table_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param TableNameQueryBody body:
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['db_branch_name', 'table_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'db_branch_name' is set
        if ('db_branch_name' not in params or
                params['db_branch_name'] is None):
            raise ValueError("Missing the required parameter `db_branch_name` when calling `query_table`")  # noqa: E501
        # verify the required parameter 'table_name' is set
        if ('table_name' not in params or
                params['table_name'] is None):
            raise ValueError("Missing the required parameter `table_name` when calling `query_table`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'db_branch_name' in params:
            path_params['db_branch_name'] = params['db_branch_name']  # noqa: E501
        if 'table_name' in params:
            path_params['table_name'] = params['table_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/db/{db_branch_name}/tables/{table_name}/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_branch(self, db_branch_name, **kwargs):  # noqa: E501
        """Free text search  # noqa: E501

        Run a free text search operation across the database branch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_branch(db_branch_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param DbBranchNameSearchBody body:
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_branch_with_http_info(db_branch_name, **kwargs)  # noqa: E501
        else:
            (data) = self.search_branch_with_http_info(db_branch_name, **kwargs)  # noqa: E501
            return data

    def search_branch_with_http_info(self, db_branch_name, **kwargs):  # noqa: E501
        """Free text search  # noqa: E501

        Run a free text search operation across the database branch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_branch_with_http_info(db_branch_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param DbBranchNameSearchBody body:
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['db_branch_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_branch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'db_branch_name' is set
        if ('db_branch_name' not in params or
                params['db_branch_name'] is None):
            raise ValueError("Missing the required parameter `db_branch_name` when calling `search_branch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'db_branch_name' in params:
            path_params['db_branch_name'] = params['db_branch_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/db/{db_branch_name}/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_record_with_id(self, db_branch_name, table_name, record_id, **kwargs):  # noqa: E501
        """Update record with ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_record_with_id(db_branch_name, table_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param RecordID record_id: The Record name (required)
        :param object body:
        :param int if_version:
        :return: InlineResponse2012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_record_with_id_with_http_info(db_branch_name, table_name, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_record_with_id_with_http_info(db_branch_name, table_name, record_id, **kwargs)  # noqa: E501
            return data

    def update_record_with_id_with_http_info(self, db_branch_name, table_name, record_id, **kwargs):  # noqa: E501
        """Update record with ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_record_with_id_with_http_info(db_branch_name, table_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param RecordID record_id: The Record name (required)
        :param object body:
        :param int if_version:
        :return: InlineResponse2012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['db_branch_name', 'table_name', 'record_id', 'body', 'if_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_record_with_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'db_branch_name' is set
        if ('db_branch_name' not in params or
                params['db_branch_name'] is None):
            raise ValueError("Missing the required parameter `db_branch_name` when calling `update_record_with_id`")  # noqa: E501
        # verify the required parameter 'table_name' is set
        if ('table_name' not in params or
                params['table_name'] is None):
            raise ValueError("Missing the required parameter `table_name` when calling `update_record_with_id`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `update_record_with_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'db_branch_name' in params:
            path_params['db_branch_name'] = params['db_branch_name']  # noqa: E501
        if 'table_name' in params:
            path_params['table_name'] = params['table_name']  # noqa: E501
        if 'record_id' in params:
            path_params['record_id'] = params['record_id']  # noqa: E501

        query_params = []
        if 'if_version' in params:
            query_params.append(('ifVersion', params['if_version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/db/{db_branch_name}/tables/{table_name}/data/{record_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upsert_record_with_id(self, db_branch_name, table_name, record_id, **kwargs):  # noqa: E501
        """Upsert record with ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_record_with_id(db_branch_name, table_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param RecordID record_id: The Record name (required)
        :param object body:
        :param int if_version:
        :return: InlineResponse2012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upsert_record_with_id_with_http_info(db_branch_name, table_name, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.upsert_record_with_id_with_http_info(db_branch_name, table_name, record_id, **kwargs)  # noqa: E501
            return data

    def upsert_record_with_id_with_http_info(self, db_branch_name, table_name, record_id, **kwargs):  # noqa: E501
        """Upsert record with ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_record_with_id_with_http_info(db_branch_name, table_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DBBranchName db_branch_name: The DBBranchName matches the pattern `{db_name}:{branch_name}`.  (required)
        :param TableName table_name: The Table name (required)
        :param RecordID record_id: The Record name (required)
        :param object body:
        :param int if_version:
        :return: InlineResponse2012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['db_branch_name', 'table_name', 'record_id', 'body', 'if_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_record_with_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'db_branch_name' is set
        if ('db_branch_name' not in params or
                params['db_branch_name'] is None):
            raise ValueError("Missing the required parameter `db_branch_name` when calling `upsert_record_with_id`")  # noqa: E501
        # verify the required parameter 'table_name' is set
        if ('table_name' not in params or
                params['table_name'] is None):
            raise ValueError("Missing the required parameter `table_name` when calling `upsert_record_with_id`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `upsert_record_with_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'db_branch_name' in params:
            path_params['db_branch_name'] = params['db_branch_name']  # noqa: E501
        if 'table_name' in params:
            path_params['table_name'] = params['table_name']  # noqa: E501
        if 'record_id' in params:
            path_params['record_id'] = params['record_id']  # noqa: E501

        query_params = []
        if 'if_version' in params:
            query_params.append(('ifVersion', params['if_version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/db/{db_branch_name}/tables/{table_name}/data/{record_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
